### 第09章 性能分析工具的使用

**查看系统性能参数**

在MySQL中，可以使用`SHOW STATUS`语句查询一些MySQL数据库服务器的性能参数、执行频率。
SHOW STATUS语句语法如下：

```sql
SHOW [GLOBAL | SESSION]STATUS LIKE'参数'；
#一些常用的性能参数效如下：
Connections:  连接MySQL服务器的次数。
Uptime:   MySQL服务器的上线运行时间，s为单位，重启mysql就重置。
Slow_queries:   慢查询的次数。
Innodb_rows_read:   Select查询返回的行数
Innodb_rows_inserted:   执行NSERT操作插入的行数
Innodb_rows_updated:    执行UPDATE操作更新的行数
Innodb_rows_deleted:    执行DELETE操作删除的行数
Com_select:  查询操作的次数。
Com_insert:  插入操作的次数。对于批量插入的INSERT操作，只累加一次。
Com_update:  更新操作的次数。
Com_delete:  删除操作的次数。
```

#### **1.** **统计SQL的查询成本：last_query_cost**

如果我们想要查看某条sql语句的查询成本，可以在执行完这条sql语句之后，通过查看当前会话中的last_query_cost变量值来得到当前查询的成本。它通常也是我们`评价一个查询的执行效率`的一个常用指标。这
个查询成本对应的是sql语句所需要`读取的页的数量`。

```mysql
# 最近的一次查询操作读取的页的数量
SHOW STATUS LIKE 'last_query_cost';
```

使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。

> SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：
>
> 1. `位置决定效率`。如果页就在数据库`缓冲池`中，那么效率是最高的，否则还需要从`内存`或者`磁盘`中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
> 2. `批量决定效率`。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。
>
> 所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到`缓冲池`中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

#### **2.** **定位执行慢的SQL：慢查询日志**

MySQL的慢查询日志，用来记录在MySQL中`响应时间超过阈值`的语句，具体指运行时间超过`long_query_time`的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为`10`，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。

默认情况下，MySQL数据库`没有开启慢查询日志`，需要我们手动来设置这个参数。`如果不是调优需要的话，一般不建议启动该参数`，因为开启慢查询日志会或多或少带来一定的性能影响。

##### **2.1** **开启慢查询日志参数**

**1.** **开启slow_query_log**

```mysql
set global slow_query_log='ON';
```

查看下慢查询日志是否开启，以及慢查询日志文件的位置：

```mysql
show variables like '%slow_query_log%';
```

**2.** **修改long_query_time阈值**，同时修改session和global

```mysql
show variables like '%long_query_time%';
```

```mysql
#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 
mysql > set global long_query_time = 1; 
mysql> show global variables like '%long_query_time%'; 

mysql> set long_query_time=1; 
mysql> show variables like '%long_query_time%';
```

==补充：配置文件中一并设置参数==
如下的方式相较于前面的命令行方式，可以看作是永久设置的方式。
修改my.cnf文件，[mysqld]下增加或修改参数long_query_time、slow_query_log和s1ow_query_log_file后，然后重启MySQL服务器。

```sql
[mysqld]
s1ow_query_log=0N#开启慢查询日志的开关
slow_query_log_file=/var/lib/mysql/atguigu-slow.log
#慢查询日志的目录和文件名信息
1ong_query_time=3#设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志
log_output=FILE
```

如果不指定存储路径，慢查询日志将默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname-slow.log。

##### **2.2** **查看慢查询数目**

```mysql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

##### **2.3** **慢查询日志分析工具：mysqldumpslow**

用于查询记录下来的慢查询语句，再用explain去具体查看。

```shell
#查看相关指令
mysqldumpslow -help
#cd /var/lib/mysql 查看慢查询日志文件名，一般为localhost-slow.log
A: -s, 是sort的意思，表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序，ac、at、al、ar，表示相应的倒序；
B: -t, 是top n的意思，即为返回前面多少条的数据；
C: -g, 是grep的意思，后边可以写一个正则匹配模式，大小写不敏感的。
D: -a, 默认情况下将查询时的语句abstruct为s(string)着n(num),加上-a之后不会abstruct。
#得到返回记录集最多的10个SQL 
mysqldumpslow -a -s r -t 10 /var/lib/mysql/localhost-slow.log
#得到访问次数最多的10个SQL 
mysqldumpslow -s c -t 10 /var/lib/mysql/localhost-slow.log
#得到按照时间排序的前10条里面含有左连接的查询语句 
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/localhost-slow.log 
#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 
mysqldumpslow -s r -t 10 /var/lib/mysql/localhost-slow.log | more
```

##### **2.4** **关闭慢查询日志**

**方式1：永久性方式**

```ini
[mysqld] 
slow_query_log=OFF
#或注释掉
[mysqld] 
#slow_query_log =OFF
```

**方式2：临时性方式**

```mysql
SET GLOBAL slow_query_log=off;
```

##### 2.5 删除慢查询日志

使用SHOW语句显示慢查询日志地址，之后删除文件即可

```sql
SHOW VARIABLES LIKE '%slow_query_1og%';
# 删除慢查询日志文件
rm /var/lib/mysql/localhost-slow.log;
```

使用命令`mysqladmin f1ush-logs`来重新生成查询日志文件，完毕会在数据目录下重新生成慢查询日志文件。

```sql
#重新生成慢查询文件前需要将确保慢查询时开启状态
show variables like '%slow_query_log%';
set global slow_query_log='ON'; #打开
mysqladmin -uroot -p flush-logs slow #重新生成
```

> 提示
> 慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。

#### **3.** **查看** **SQL** **执行成本：SHOW PROFILE**

```mysql
show variables like 'profiling';
#开启
set profiling = 'ON';
#查看
show profiles;
show profile cpu,block io for query 2;
# 如果其中的executing过程太慢，就可以用explain执行计划继续分析
```

show profile的常用查询参数：
①ALL:显示所有的开销信息。

②BLOCK IO:显示块IO开销。

③CONTEXT SWITCHES:上下文切换开销。

④CPU:显示CPU开销信息。

⑤IPC:显示发送和接收开销信息。

⑥MEMORY:显示内存开销信息。

⑦PAGE FAULTS:显示页面错误开销信息.

⑧SOURCE:显示和Source_function,Source_file,Source._line相关的开销信息。

⑨SWAPS:显示交换次数开销信息。

##### 日常开发需注意的结论：

①`converting HEAP to MyISAM`:查询结果太大，内存不够，数据往磁盘上搬了。

②`Creating tmp table`：创建临时表。先拷贝数据到临时表，用完后再删除临时表。
③`Copying to tmp  table on disk`:把内存中临时表复制到磁盘上，警惕！
④`locked`。
如果在show profilei诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。

不过SHOW PROFILE命令将被弃用，我们可以从information_schema中的profiling数据表进行查看。

#### **4.** **分析查询语句：EXPLAIN**

作用：查看执行计划，并不是执行语句

`MySQL5.6.3`以前只能`EXPLAIN SELECT`;MYSQL5.6.3以后就可以`EXPLAIN SELECT,UPDATE,DELETE`。在5.7以前的版本中，想要显示`partitions`需要使用`explain partitionts`命令；想要显示`filtered`需要使用`explain extended`命令。在5.7版本后，默认explain直接显示partitions和lfiltered中的信息。

##### **4.1** **基本语法**

```mysql
EXPLAIN SELECT select_options 
#或者
DESCRIBE SELECT select_options
```

EXPLAIN 语句输出的各个列的作用如下：

| 列名          | 描述                                                     |
| ------------- | -------------------------------------------------------- |
| id            | 在一个大的查询语句中每个SELECT关键字都对应一个`唯一的id` |
| select_type   | SELECT关键字对应的那个`查询的类型`                       |
| table         | 表名                                                     |
| partitions    | 匹配的分区信息                                           |
| `type`        | 针对单表的访问方法                                       |
| possible_keys | 可能用到的索引                                           |
| key           | 实际上使用的索引                                         |
| `key_len`     | 实际使用到的索引长度                                     |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息   |
| `rows`        | 预估的需要读取的记录条数                                 |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比             |
| `Extra`       | 一些额外的信息                                           |

##### **4.2 EXPLAIN各列作用**

**1. table**

不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行`单表访问`的，所以MySQL规定**EXPLAIN语句输出的每条记录都对应着某个单表的访问方法**，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。只要查找了几张表，explain就有几条数据

**2. id**

- **id如果相同，可以认为是一组，从上往下顺序执行**
- **在所有组中，`id值越大，优先级越高，越先执行`**
- **关注点：`id号每个号码，表示一趟独立的查询`,一个sql的查询趟数越少越好**
- **一个语句中一个select对应着一个id，但并不绝对。查询优化器可能对涉及子查询的查询语句进行重写,转变为多表查询的操作**

**3. select_type,查询类型**

MySQL为每一个SELECT:关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了
某个小查询的select_type属性，就知道了`这个小查询在整个大查询中扮演了一个什么角色`，看一下select_.type都能取哪些值，

+ 查询语句中`不包含UNION或者子查询的查询`都算作是`SIMPLE`类型，包括多表连接。
+ 对于`包含UNION或者UNION ALL和子查询`的大查询来说，它是由几个小查询组成的，
  + 其中`最左边`的那个查询的select_type值就是`PRIMARY`，对于包含`UNION`或者`UNION ALL`的大查询来说，其余的小查询的select_type值就是`UNION`
  + `UNION`查询的去重工作，针对该临时表的查询的select_type就是`UNION RESULT`
  + 对于子查询来说，如果查询优化器不把子查询变为多表连接的形式，并且该子查询是不相关子查询。该子查询的第一个`SELECT`关键字代表的那个查询的select_type就是`SUBQUERY`
  + 对于子查询来说，如果查询优化器不把子查询变为多表连接的形式，并且该子查询是相关子查询。则该子查询的第一个`SELECT`关键字代表的那个查询的select_type就是`DEPENDENT SUBQUERY`。此类型可能会被执行多次。因为是相关子查询

**4. partitions**

+ 代表`分区表中的命中情况`，非分区表，该项为NULL。一般情况下我们的查询语句的执行计划的partitions
  列的值都是NULL。
+ https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html

**5. type（重点）**

执行计划的一条记录就代表着MySQL对某个表的`执行查询时的访问方法`，又称“访问类型”，其中的type列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到type列的值是ref,表明MySQL即将使用ref访问
方法来执行对s1表的查询。

**结果值从最好到最坏依次是：** **system > const > eq_ref > ref** **> fulltext > ref_or_null > index_merge > unique_subquery > index_subquery >** **range > index > ALL** 

**SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）**

**6. possible_keys和key**

**7. key_len（重点）**

**key_len的长度计算公式：**

```
varchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) 

varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)

char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) 

char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)
```

**8. ref** 

**9. rows（重点）**

预估的需要读取的记录条数

**10. filtered**

**11. Extra**

#### **5. EXPLAIN的进一步使用**

##### **5.1 EXPLAIN四种输出格式**

这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：`传统格式`，`JSON格式`，`TREE格式`以及`可视化输出`。用户可以根据需要选择适用于自己的格式。

**1.** **传统格式**

**2. JSON格式** 

JSON格式：在EXPLAIN单词和真正的查询语句中间加上`FORMAT=JSON`。用于查看执行成本`cost_info`

**3. TREE格式**

TREE格式是8.0.16版本之后引入的新格式，主要根据查询的`各个部分之间的关系`和`各部分的执行顺序`来描述如何查询。

**4.** **可视化输出**

可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。

##### **5.2 SHOW WARNINGS的使用** 

```mysql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
# 查看优化后的执行语句
mysql> SHOW WARNINGS\G
```

#### **6.** **分析优化器执行计划：trace**

```mysql
# 开启
SET optimizer_trace="enabled=on",end_markers_in_json=on; 
# 设置大小
set optimizer_trace_max_mem_size=1000000;
# 使用
select * from student where id < 10;
select * from information_schema.optimizer_trace\G
```

#### **7. MySQL监控分析视图-sys schema** 

**7.1 Sys schema视图使用场景**

**索引情况**

```mysql
#1. 查询冗余索引 
select * from sys.schema_redundant_indexes; 
#2. 查询未使用过的索引 
select * from sys.schema_unused_indexes; 
#3. 查询索引的使用情况 
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema='dbname' ;
```

**表相关**

```mysql
# 1. 查询表的访问量 
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; 
# 2. 查询占用bufferpool较多的表 
select object_schema,object_name,allocated,data
from sys.innodb_buffer_stats_by_table order by allocated limit 10; 
# 3. 查看表的全表扫描情况 
select * from sys.statements_with_full_table_scans where db='dbname';
```

**语句相关**

```mysql
#1. 监控SQL执行的频率 
select db,exec_count,query from sys.statement_analysis order by exec_count desc; 
#2. 监控使用了排序的SQL 
select db,exec_count,first_seen,last_seen,query
from sys.statements_with_sorting limit 1; 
#3. 监控使用了临时表或者磁盘临时表的SQL 
select db,exec_count,tmp_tables,tmp_disk_tables,query
from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0 order by (tmp_tables+tmp_disk_tables) desc;
```

**IO相关**

```mysql
#1. 查看消耗磁盘IO的文件 
select file,avg_read,avg_write,avg_read+avg_write as avg_io
from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

**Innodb** **相关**

```mysql
#1. 行锁阻塞情况 
select * from sys.innodb_lock_waits;
```

### 
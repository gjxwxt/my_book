#### 小程序开发总结
1. 在mainfest.json中的appid如果写了，在用hbuilder打开微信开发者工具的时候就会校验你微信开发者工具登录的账户，是否是该appid应用的开发人员，如果不是就不会打开，需要管理员用微信号添加上。
2. 如果不填appid，编译过后项目会被微信开发者工具打开，但是很多微信的api会限制使用，例如wx.login
3. 可以先填一个自己拥有开发者权限或者自己申请的小程序的appid开发，如果管理员开发者权限还没给，这样也可以先开发着
4. 用hbuilder开发的小程序，可以在编译后打开的微信开发者工具中上传，会根据appid上传
5. 上传之后，如果有运营权限，可以在微信公众平台看到该小程序的信息，选择设为体验版本之后提交审核
6. 小程序的版本回退很方便，每个版本都会被明确记录下来，可以选择回退到具体的某个版本
7. hbuilder开发小程序时发送请求时需要使用uni.request，也可使用一些封装好的插件，例如flyio
8. 如何区分小程序的不通环境：
9. 小程序图片展示支持base64，直接用image的src='data:image/jpg;base64,' + base64字符；但是音频不支持base64
10. <font style="color:#DF2A3F;">小程序分包</font>步骤：首先主包在pages目录下，每个分包和pages目录同级。修改manifest.json和pages.json
    1. ![](https://cdn.nlark.com/yuque/0/2023/png/28792475/1687680802151-331ad307-de7b-43b2-8d75-36bc1ef8a070.png)
    2. manifest.json文件中针对小程序配置中，添加属性"optimization":{"subPackages":true}![](https://cdn.nlark.com/yuque/0/2023/png/28792475/1687680883048-f7b649df-abe9-4bf1-98ab-d0afeaaf05e1.png)
    3. 修改pages.json文件，添加subpackages属性，每个分包都有两个属性，root和pages![](https://cdn.nlark.com/yuque/0/2023/png/28792475/1687680909822-746d5341-07dd-430c-a031-c9eb7daff9c0.png)

#### git使用总结
1. git clone =>git branch 查看分支=>git checkout develop 切换到开发分支=>开发完成之后git add /commit/push=>git status查看状态=>git checkout master切换到master分支=>git pull 拉取最新的master内容=>git merge develop=>git add/commit/push合并完毕=>git checkout develop切换回开发分支继续开发
2. git clone之后没有远程分支：git branch -a 查看所有分支==>git fetch==>git checkout -b 分支名 origin/分支名，会创建新的分支与远程分支链接并转到该分支上==>git pull origin 分支名，拉取该远程分支，于是创建了新的本地分支
3. 在切换分支的时候，如果文件进行了修改没有commit是切换不了分支的，否则会覆盖写过的内容
4. 如果是不经意的修改，可以通过git restore 文件名  将修改回退到之前的版本
5. git merge这块还不是很清楚[使用分支——处理Git merge 冲突](https://zhuanlan.zhihu.com/p/473833514)，
6. git commit 的标准git commit -m'<type>(scope):description'
+ type:

<font style="color:rgb(77, 77, 77);">feat: 新特性</font>  
<font style="color:rgb(77, 77, 77);">fix: 修改问题</font>  
<font style="color:rgb(77, 77, 77);">refactor: </font>[代码重构](https://so.csdn.net/so/search?q=%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84&spm=1001.2101.3001.7020)  
<font style="color:rgb(77, 77, 77);">docs: 文档修改</font>  
<font style="color:rgb(77, 77, 77);">style: 代码格式修改, 注意不是 css 修改</font>  
<font style="color:rgb(77, 77, 77);">test: </font>[测试用例](https://so.csdn.net/so/search?q=%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B&spm=1001.2101.3001.7020)<font style="color:rgb(77, 77, 77);">修改</font>  
<font style="color:rgb(77, 77, 77);">chore: 其他修改, 比如构建流程, 依赖管理.</font>  
<font style="color:rgb(77, 77, 77);">pref: 性能提升的修改</font>  
<font style="color:rgb(77, 77, 77);">build: 对项目构建或者依赖的改动</font>  
<font style="color:rgb(77, 77, 77);">ci: CI 的修改</font>  
<font style="color:rgb(77, 77, 77);">revert: revert 前一个 commit</font>  
<font style="color:rgb(77, 77, 77);">scope: commit 影响的范围, 比如: route, component, utils, build…</font>  
<font style="color:rgb(77, 77, 77);">subject: commit 的概述, 建议符合 50/72 formatting</font>  
<font style="color:rgb(77, 77, 77);">body: commit 具体修改内容, 可以分为多行, 建议符合 50/72 formatting</font>  
<font style="color:rgb(77, 77, 77);">footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</font>

+ <font style="color:rgb(38, 38, 38);">scope:global/某些具体的文件</font>

<font style="color:rgb(38, 38, 38);"></font>

#### <font style="color:rgb(38, 38, 38);">vue开发总结</font>
1. 路由懒加载小细节：<font style="color:rgb(81, 87, 103);">一般来说当我们的项目越来越大的时候，我们打包的文件也越来越大。这时候我们的首屏加载就会很慢。因此我们会使用到路由的懒加载机制来对我们的模块进行划分。</font>  
<font style="color:rgb(81, 87, 103);">但是如果我们使用了路由懒加载，但是这样就会导致打包出很多个chunk块。项目越来越大就会导致chunk块越来越多。</font>  
<font style="color:rgb(81, 87, 103);">        如果一个很大的布局组件 需要一次性加载6个及以上的子组件 那么浏览器需要发起6个及以上的子线程去请求这些文件回来 那么会占用一定的线程池时间 比如：img video audio 的资源 将被短暂阻塞无法加载 因为浏览器线程是有并发限制的 一般谷歌浏览器线程是分为1个ui主线程 6个请求子线程 假设用户在移动端 等待渲染时间过久 这个体验是极差的。所以为了提高用户体验性，尽可能的减少http请求，让其线程不那么繁忙，还有空闲时间去做其他事情。</font>  
<font style="color:rgb(81, 87, 103);">例如：”/* webpackChunkName: “A” */ 这个指定了打包chunk块的名字，这样我们就能将同类路由下的左键打包到同一个 chunk 块</font>

```javascript
const routes = [{
		path: '/A',
		component: () => import(/* webpackChunkName: "A" */ './components/A.vue'),
				children: [
						{
						path: 'A1',
						component: () => import(/* webpackChunkName: "A" */ './components/A1')
						},
						{
						path: 'A2',
						component: () => import(/* webpackChunkName: "A" */ './components/A2')
						}
				]
		}
]
```

<font style="color:rgb(81, 87, 103);">这样webpack打包出来 就不会有很多个chunk了 不仅可以将类同的路由文件合并 还减少了http请求子线程的并发负担 本质上也降低了浏览器的压力</font>

<font style="color:rgb(81, 87, 103);"></font>


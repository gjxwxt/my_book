总体目标： 回归本身，根据需求不断充实自身
问题： 为什么感觉自己25和之前20一样呢，放过自己，一样在哪呢，和再早的自己又有什么不同呢，确实，没有现实的阶段性的评价无法把握z轴方向上的起伏，啥也不管，写点东西，有些能考量，有些目前无法量化，但是可以实物化。有时候计划完善了反而会弱化行动
自我分析：输入太少是最为关键的，提高自己输入的方式


考量自身：
+ 力量：
+ 速度：
+ 弹跳高度
+ 爆发力
+ 耐力
+ 计算速度
+ 记忆力
+ 思维
+ 描述能力
+ 即兴评述
+ 当前目标
	+ 工作
		+ vue3的全面解析
	+ 个人
		+ 完善的声音克隆，简化克隆流程
···

2024-03-20 

分三个任务： 
+ framer motion中的滚动动画
+ 渲染模式以及nextjs的部署
	+ csr、ssr、ssg、isg
+ 理顺一下这个视频地图组件
	+ 如何创建通用型组件
		+ 主体视频（作为背景）
		+ 头部视频
		+ svg（地图svg、地名svg）
		+ 内容（）

2024-03-21

分三个任务：
+ next官网案例
+ ts常用的语法糖整理

2024-03-22

分三个任务
+ next文档整理
+ clash网络配置讲解
+ bind传多个参数，
+ 来活了就是




react的classname库

```jsx
import styles from './alert.module.css'
import cn from 'classnames'

export default function Alert({ children, type }) {
  return (
    <div
      className={cn({
        [styles.success]: type === 'success',
        [styles.error]: type === 'error'
      })}
    >
      {children}
    </div>
  )
}
```
解析markdown文件 gray-matter

getStaticProps用于构建时获取数据给 当前页面输入props
- In **development** (`npm run dev` or `yarn dev`), [`getStaticProps`](https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticprops-static-generation) runs on _every request_.
- In **production**, [`getStaticProps`](https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticprops-static-generation) runs at _build time_.
```jsx
// posts will be populated at build time by getStaticProps()
function Blog({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li>{post.title}</li>
      ))}
    </ul>
  )
}

// This function gets called at build time on server-side.
// It won't be called on client-side, so you can even do
// direct database queries. See the "Technical details" section.
export async function getStaticProps() {
  // Call an external API endpoint to get posts.
  // You can use any data fetching library
  const res = await fetch('https://.../posts')
  const posts = await res.json()

  // By returning { props: { posts } }, the Blog component
  // will receive `posts` as a prop at build time
  return {
    props: {
      posts,
    },
  }
}

export default Blog
```

`getServerSideProps`是服务端渲染时用的
```jsx
function Page({ data }) {
  // Render data...
}

// This gets called on every request
export async function getServerSideProps() {
  // Fetch data from external API
  const res = await fetch(`https://.../data`)
  const data = await res.json()

  // Pass data to the page via props
  return { props: { data } }
}

export default Page
```

我不想服务端渲染，我就想浏览器渲染，当js加载的时候采取加载数据。适用于类似仪表盘的，用不着seo，每个用户都不一样
This approach works well for user dashboard pages, for example. Because a dashboard is a private, user-specific page, SEO is not relevant, and the page doesn’t need to be [pre-rendered](https://www.nextjs.cn/docs/basic-features/pages#pre-rendering). The data is frequently updated, which requires request-time data fetching.

Next.js 背后的团队创建了一个名为 SWR 的用于数据获取的 React hook。如果您在客户端获取数据，我们强烈推荐它。它处理缓存、重新验证、焦点跟踪、按时间间隔重新获取等。Check out the [SWR documentation](https://swr.vercel.app/) to learn more.

Again, you can get in-depth information about [`getStaticProps`](https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticprops-static-generation) and [`getServerSideProps`](https://www.nextjs.cn/docs/basic-features/data-fetching#getserversideprops-server-side-rendering) in the [Data Fetching documentation](https://www.nextjs.cn/docs/basic-features/data-fetching)

```jsx
import useSWR from 'swr'

function Profile() {
  const { data, error } = useSWR('/api/user', fetch)

  if (error) return <div>failed to load</div>
  if (!data) return <div>loading...</div>
  return <div>hello {data.name}!</div>
}
```
![](https://s3.bmp.ovh/imgs/2024/09/09/18cce1bff8d71b69.png)


构建时生成不同id的不同页面，首先根据getStaticPaths返回可能的id列表，然后根据getStaticProps根据拿到的id去请求data，拿到data之后作为props传入页面

页面是post/[id].jsx
```jsx
import remark from 'remark'
import html from 'remark-html'
import Layout from '../../components/layout'

export async function getPostData(id) {
  const fullPath = path.join(postsDirectory, `${id}.md`)
  const fileContents = fs.readFileSync(fullPath, 'utf8')

  // Use gray-matter to parse the post metadata section
  const matterResult = matter(fileContents)

  // Use remark to convert markdown into HTML string
  const processedContent = await remark()
    .use(html)
    .process(matterResult.content)
  const contentHtml = processedContent.toString()

  // Combine the data with the id and contentHtml
  return {
    id,
    contentHtml,
    ...matterResult.data
  }
}

export function getAllPostIds() {
  const fileNames = fs.readdirSync(postsDirectory)

  // Returns an array that looks like this:
  // [
  //   {
  //     params: {
  //       id: 'ssg-ssr'
  //     }
  //   },
  //   {
  //     params: {
  //       id: 'pre-rendering'
  //     }
  //   }
  // ]
  return fileNames.map(fileName => {
    return {
      params: {
        id: fileName.replace(/\.md$/, '')
      }
    }
  })
}

export async function getStaticPaths() {
  // Return a list of possible value for id
  const paths = getAllPostIds()
  return {
	paths,
	fallback: false
  }
}

export async function getStaticProps({ params }) {
  // Fetch necessary data for the blog post using params.id
  const postData = await getPostData(params.id)
  return {
    props: {
      postData
    }
  }
}

export default function Post({ postData }) {
  return (
    <Layout>
	  <Head>
        <title>{postData.title}</title>
      </Head>
      {postData.title}
      <br />
      {postData.id}
      <br />
      {postData.date}
      <br />
      <div dangerouslySetInnerHTML={{ __html: postData.contentHtml }} />
    </Layout>
  )
}
```


app文件夹下的`favicon.ico` and `opengraph-image.jpg`.将自动识别并使用这些文件作为您的网站图标和 OG 图像
![](https://s3.bmp.ovh/imgs/2024/09/09/96c01d7b5516bb3c.png)
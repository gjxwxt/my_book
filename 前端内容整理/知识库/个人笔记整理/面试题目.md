<font style="color:rgb(51, 51, 51);">大体方向：事件循环原理，闭包，调用栈，Promise，ES6， 工程化，webpack, 性能优化，跨域，安全问题， React、Redux 思想，Virtual DOM，Diff 算法， 移动端布局，浏览器渲染原理 等</font>

<font style="color:rgb(51, 51, 51);">还有手写代码，主要考察一些基本 API 和 ES6 的使用。最常见是在 Array、String prototype 上写一个函数。比如 </font><font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">'abcd'.f() => 'd-c-b-a'</font>

<font style="color:rgb(51, 51, 51);">还有一些常用的函数，比如 bind ，throttle, debounce 等</font>

#### <font style="color:rgb(51, 51, 51);">一、css</font>
+ <font style="color:rgb(62, 62, 62);">BFC是什么? 哪些属性可以构成一个BFC呢?</font>
+ <font style="color:rgb(62, 62, 62);">postion属性，static是什么表现? static在文档流里吗?</font>
+ <font style="color:rgb(62, 62, 62);">css 三列等宽布局如何实现? flex 1是代表什么意思？分别有哪些属性?</font>

#### 二、js与浏览器相关
<details class="lake-collapse"><summary id="u56bf8bca"><span class="ne-text" style="color: rgb(62, 62, 62); font-size: 16px">闭包是什么? 闭包的用途?</span></summary><ul class="ne-ul"><li id="u8eb01284" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">堆栈的存储规则</span><span id="kWDZ9" class="ne-bookmark-inline" style="font-size: 16px"><a href="https://blog.csdn.net/Liukairui/article/details/125496267" target="_blank">JavaScript变量存储机制_js存储全局参数_Liukairui的博客-CSDN博客</a></span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u326bf3bf" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">局部变量存储在作用域所在的栈空间中</span></li><li id="ua103d8f5" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">全局变量（堆中）</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u844bcc8c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">function和var定义的变量会存在window对象中</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u30bd056d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">let const定义的变量存在Script对象中（堆中）</span></li><li id="u7802d4a8" data-lake-index-type="0"><span class="ne-text">闭包中的变量会被父函数执行时存储在以父函数标识的Closure对象中（堆中），所以闭包才能访问到已经出栈的函数变量</span></li><li id="u10e789ef" data-lake-index-type="0"><span class="ne-text" style="color: rgba(0, 0, 0, 0.75); font-size: 16px">字符串: 存在堆里, 栈中为引用地址, 如果存在相同字符串, 则引用地址相同.</span></li><li id="u474b27c5" data-lake-index-type="0"><span class="ne-text" style="color: rgba(0, 0, 0, 0.75); font-size: 16px">数字: 小整数存在栈中, 其他类型存在堆中</span></li><li id="u2f36e12f" data-lake-index-type="0"><span class="ne-text" style="color: rgba(0, 0, 0, 0.75); font-size: 16px">其他类型: 引擎初始化时分配唯一地址, 栈中的变量存的是唯一的引用.</span></li></ul></ul><ul class="ne-ul"><li id="u586c7cc7" data-lake-index-type="0"></li></ul></details>
<details class="lake-collapse"><summary id="udb77bc62"><span class="ne-text" style="color: rgb(62, 62, 62); font-size: 16px">0.1+0.2 != 0.3</span></summary><p id="uefe4961b" class="ne-p"><span class="ne-text" style="font-size: 16px">js中数字以二进制形式存储，不论整数还是小数，都以</span><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 19px">双精度浮点数</span><span class="ne-text" style="font-size: 16px">进行存储，大小是</span><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 19px">8bytes，</span></p><ul class="ne-ul"><li id="u1ac84b20" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">数字转二进制：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ud324d03c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">整数一直÷2取余，一直除完将取的余倒序排列</span></li><li id="u2343b9f1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">小数部分×2，取整数部分，之后小数部分继续×2，继续取整数部分，直到小数部分为0</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u2a8a4fe5" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">1.2二进制标识</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u760b3970" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">1转为二进制就是1</span></li><li id="u85a79f9d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">0.2转为二进制首先</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="4" class="ne-ul"><li id="u3d61cf4f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">0.2×2 = 0.4   取0</span></li><li id="u08975085" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">0.4×2 = 0.8   取0</span></li><li id="u4712cbda" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">0.8×2 = 1.6   取1</span></li><li id="u731dd4ad" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">0.6×2 = 1.2   取1</span></li><li id="ua6a0a5a3" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">0.2×2 = 0.4   取0</span></li><li id="uf0288a88" data-lake-index-type="0"><span class="ne-text" style="color: rgb(1, 1, 1); font-size: 16px">....... 开始循环</span></li></ul></ul></ul></ul></ul><ul class="ne-ul"><li id="uac99cbe3" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">js采用科学计数法对二进制进行存储</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u83f27aca" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">第一位表示正负，正0</span></li><li id="u82dfe7e8" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">指数位（11bits）：表示</span><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">范围，科学计数法偏移的位数+1023转二进制的补码</span></li><li id="u09660094" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">尾数（52bits）：表示精度，科学计数法小数部分，多出的位数舍0进1</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ub819d4a3" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">0.1转科学计数法：</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u88990d92" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">0.1转二进制：00011 0011 0011 .。。。</span></li><li id="u569965f0" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">0.00011.。。转科学计数法： （1.10011。。。）2^-4</span></li><li id="u4067f672" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">偏移量-4+1023 = 1019，二进制表示1111111011，因为是11位所以前面补0为 01111111011，正数补码是其本身，负数补码是原码的基础上, 符号位不变, 其余各位取反, 最后+1。因为是正数，所以不变</span></li><li id="u367957ef" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">尾数部分就是10011。。。。，最后50.51.52.位是001，因为53位是1，所以52位进1，最后50，51，52位变成了010，</span></li></ul></ul></ul></ul><ul class="ne-ul"><li id="u0b9f2570" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">正是因为0.1和0.2存储中的尾数都进了一位，精度降低，所以相加出来不等于0.3</span></li></ul></details>
<details class="lake-collapse"><summary id="ue5ae635e"><span class="ne-text" style="color: rgb(62, 62, 62); font-size: 16px">简述事件循环原理</span></summary><p id="u94cb9975" class="ne-p"><span class="ne-text" style="font-size: 16px">单线程是异步产生的原因，事件循环是异步的实现方式。</span></p><p id="u8e3193af" class="ne-p"><span class="ne-text" style="font-size: 16px">浏览器加载js是单线程的，一个任务完不成就不能执行下个任务，如果全部都是同步，那么耗时任务执行不完，任务就不向下执行，页面完全卡死。异步是将耗时的操作给其他线程做，做完之后在消息队列中排队依次执行，排队也分优先级，微队列&gt;交互队列&gt;延时队列。如果多个队列中都有任务，就从优先级高的队列中先取任务执行，以此来解决阻塞问题。</span></p></details>
<details class="lake-collapse"><summary id="uaff833dd"><span class="ne-text" style="color: rgb(62, 62, 62); font-size: 16px">Promise then 第二个参数和catch的区别是什么?</span></summary><p id="u243440a6" class="ne-p"><span class="ne-text" style="font-size: 16px">then中第二个参数接收不到在then中抛出的错误，catch可以</span></p></details>
<details class="lake-collapse"><summary id="u1477246a"><span class="ne-text" style="font-size: 16px">浏览器同源策略产生和流程</span></summary><ol class="ne-ol"><li id="ua9b5e40b" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">dom同源策略</span></li></ol><p id="u517de775" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">如果没有 DOM 同源策略，也就是说</span><span class="ne-text" style="color: #E8323C; font-size: 16px">不同域的 iframe 之间可以相互访问</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，那么黑客可以这样进行攻击： 做一个假网站，里面用 iframe 嵌套一个银行网站 </span><span class="ne-text">mybank.com。</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。 这时如果用户输入账号密码，我们的主网站可以跨域访问到 </span><span class="ne-text">mybank.com</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 的 dom 节点，就可以拿到用户的账户密码了。 </span></p><ol start="2" class="ne-ol"><li id="u7f4b0404" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">XMLHttpRequest 同源策略</span></li></ol><p id="uc20197c0" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">如果没有 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击： 用户登录了自己的银行页面 </span><span class="ne-text">mybank.com，http://mybank.com</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 向用户的 cookie 中添加用户标识。 用户浏览了恶意页面 </span><span class="ne-text">evil.com</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">, 执行了页面中的恶意 AJAX 请求代码。</span><span class="ne-text" style="color: #E8323C; font-size: 16px"> </span><span class="ne-text" style="color: #E8323C">evil.com</span><span class="ne-text" style="color: #E8323C; font-size: 16px"> 向 </span><span class="ne-text" style="color: #E8323C">mybank.com</span><span class="ne-text" style="color: #E8323C; font-size: 16px"> 发起 AJAX HTTP 请求</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，请求会默认把 </span><span class="ne-text">mybank.com</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 对应 cookie 也同时发送过去。 银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。 而且由于 Ajax 在后台执行，用户无法感知这一过程。 </span></p><ol start="3" class="ne-ol"><li id="u2150af7e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器发送简单请求的时候带着origin，服务器返回的时候请求头中的</span><span class="ne-text" style="color: rgb(194, 24, 91); background-color: rgb(255, 244, 244); font-size: 12px">Access-Control-Allow-Origin</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">判断是不是允许该origin的请求返回，允许就可以拿到数据</span></li><li id="u5168747b" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">options请求的产生：先问问允不允许之后再向服务器发送请求，相当于敲一下门。</span></li></ol><p id="ueb010aa5" class="ne-p"><span class="ne-text">满足下面的所有条件就不会产生预检请求，也就是该请求是简单请求：</span></p><p id="u55566f7a" class="ne-p"><span class="ne-text">● 请求方法是GET、POST、HEAD其中任意一个</span></p><p id="u2684c70f" class="ne-p"><span class="ne-text">● 必须是下面定义对CORS安全的首部字段集合，不能是集合之外的其他首部字段。</span></p><p id="uc712720d" class="ne-p"><span class="ne-text">Accept、Accept-Language、Content-Language、Content-Type、DPR、Downlink、Save-Data、Viewport-Width、Width。</span></p><p id="ue2b34297" class="ne-p"><span class="ne-text">● Content-Type的值必须是text/plain、multipart/form-data、application/x-www-form-urlencoded中任意一个值</span></p><p id="udd31d404" class="ne-p"><span class="ne-text">满足上面所有的条件才不会发送预检请求，所以当</span><span class="ne-text" style="color: #DF2A3F">application/json</span><span class="ne-text">格式编码，或者使用</span><span class="ne-text" style="color: #DF2A3F">自定义请求头</span><span class="ne-text">都会触发CORS的预检请求。</span></p></details>
+ <font style="color:rgb(62, 62, 62);">Promise finally 怎么实现的</font>
+ <font style="color:rgb(62, 62, 62);">你觉得js里this的设计怎么样? 有没有什么缺点啥的</font>
+ <font style="color:rgb(62, 62, 62);">装饰器</font>
+ <font style="color:rgb(62, 62, 62);">generator 是如何做到中断和恢复的</font>
+ <font style="color:rgb(62, 62, 62);">function 和 箭头函数的定义有什么区别? 导致了在this指向这块表现不同</font>
+ <font style="color:rgb(62, 62, 62);">导致js里this指向混乱的原因是什么?</font>
+ <font style="color:rgb(62, 62, 62);">Set和Map</font>
+ <font style="color:rgb(62, 62, 62);"> ES5和ES6的继承? 这两种方式除了写法, 还有其他区别吗</font>
+ <font style="color:rgb(62, 62, 62);">async await的原理是什么?</font>
+ <font style="color:rgb(62, 62, 62);">async/await, generator, promise这三者的关联和区别是什么?</font>
+ <font style="color:rgb(62, 62, 62);">作用域链</font>
+ <font style="color:rgb(62, 62, 62);">sleep函数</font>
+ <font style="color:rgb(62, 62, 62);">js超过Number最大值的数怎么处理?</font>
+ <font style="color:rgb(37, 41, 51);">实现一个响应式网站如何做</font>
+ <font style="color:rgb(37, 41, 51);">设计模式</font>

<details class="lake-collapse"><summary id="u270b148c"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">浏览器的垃圾回收机制与内存泄漏</span></summary><p id="u9b44a220" class="ne-p"><br></p></details>
+ <font style="color:rgb(37, 41, 51);">浏览器的渲染流程</font>
+ <font style="color:rgb(37, 41, 51);">浏览器多进程的渲染优势</font>
+ <font style="color:rgb(37, 41, 51);">手写深拷贝、节流和</font>
+ <font style="color:rgb(37, 41, 51);">大文件分块上传以及断点续传</font>

<details class="lake-collapse"><summary id="u7fafda40"><span class="ne-text" style="font-size: 16px">手写call 。 bind。 apply</span></summary><ul class="ne-ul"><li id="ub47995e3" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">首先了解功能：</span><span class="ne-text" style="color: rgb(68, 68, 68)">当一个object没有某个方法，但是其他的有，可以借助call或apply用其它对象的方法来操作。</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u222e8f74" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">call: functionA.call(a,参数1，参数2)  将functionA中的this指向a，参数1，2是传入函数的参数。</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u469b91c6" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">第一个参数如果是null或者undefined，函数this指向window</span></li><li id="u65c1e050" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">第一个参数如果是对象或者函数，this指向对象或者函数的引用</span></li><li id="ud36ac103" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">第一个参数如果是字面量，this指向</span><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">其对应的包装对象，如 String、Number、Boolean</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u42902c52" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">apply：和call同样功能，就是参数传入是数组形式，例如Math.max(null,[1,2,3])</span></li><li id="u47b823f0" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">bind：和call同样功能，就是返回的是一个新的函数。</span></li></ul></ul><pre data-language="javascript" id="rxBpg" class="ne-codeblock language-javascript"><code>Function.prototype.myCall = function (context, ...args) {
  if (!context || context === null) {
    context = window;
  }
  // 创造唯一的key值  作为我们构造的context内部方法名
  let fn = Symbol();
  context[fn] = this; //this指向调用call的函数
  // 执行函数并返回结果 相当于把自身作为传入的context的方法进行调用了
  return context[fn](...args);
};</code></pre><pre data-language="javascript" id="qY33J" class="ne-codeblock language-javascript"><code>// apply原理一致  只是第二个参数是传入的数组
Function.prototype.myApply = function (context, args) {
  if (!context || context === null) {
    context = window;
  }
  // 创造唯一的key值  作为我们构造的context内部方法名
  let fn = Symbol();
  context[fn] = this;
  // 执行函数并返回结果
  return context[fn](...args);
};</code></pre><pre data-language="javascript" id="hB2gq" class="ne-codeblock language-javascript"><code>Function.prototype.myBind = function () {
  if (typeof this !== 'function') throw 'caller must be a function'
  let self = this // 这里是关键 用来和new出来的比较原型来判断是否为new出来的  当前函数对象
  let context = arguments[0]
  let args = Array.prototype.slice.call(arguments, 1) // 旧：参数
  let fn = function () {
    let fnArgs = Array.prototype.slice.call(arguments) // 新：参数
    // bind 函数的参数 + 延迟函数的参数
    // 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
    self.apply(this instanceof self ? this : context, args.concat(fnArgs))
  }
  fn.prototype = Object.create(self.prototype) // 维护原型
  return fn
}</code></pre></details>
#### 三、vue
+ <font style="color:rgb(62, 62, 62);">虚拟dom是什么? 原理? 优缺点?</font>
+ <font style="color:rgb(62, 62, 62);">vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快?</font>
+ <font style="color:rgb(62, 62, 62);">vue 和 react 里的key的作用是什么? 为什么不能用Index？用了会怎样? 如果不加key会怎样?</font>
+ <font style="color:rgb(62, 62, 62);">vue 双向绑定的原理是什么?</font>
+ <font style="color:rgb(62, 62, 62);">vue 的keep-alive的作用是什么？怎么实现的？如何刷新的?</font>
+ <font style="color:rgb(62, 62, 62);">vue 是怎么解析template的? template会变成什么?</font>
+ <font style="color:rgb(62, 62, 62);">如何解析指令? 模板变量? html标签</font>
+ <font style="color:rgb(62, 62, 62);">用过vue 的render吗? render和template有什么关系</font>
+ <font style="color:rgb(62, 62, 62);">vue 向 react迁移是怎么做的? 怎么保证兼容的</font>
+ <font style="color:rgb(62, 62, 62);">vue的双向绑定原理</font>
+ <font style="color:rgb(62, 62, 62);">vue 父子组件的通信方式</font>
+ <font style="color:rgb(37, 41, 51);">Vue的nextTick是怎么实现的</font>
+ <font style="color:rgb(62, 62, 62);">vue的keep-alive原理以及生命周期</font>
+ <font style="color:rgb(62, 62, 62);">vue有自己封装一些指令吗</font>
+ <font style="color:rgb(62, 62, 62);">vue2和vue3区别；</font><font style="color:rgb(37, 41, 51);">vue3相比vue2，它在diff算法上做了哪些优化</font>
+ <font style="color:rgb(37, 41, 51);">设计组件要考虑的因素</font>
+ <font style="color:rgb(37, 41, 51);">vue2项目如何快速用vue3来重构</font>
+ <font style="color:rgb(37, 41, 51);">选择项目使用框架的因素有哪些</font>

<details class="lake-collapse"><summary id="u06500477"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">vue单页面应用的原理以及如何nginx搭配使用history模式</span></summary><ol class="ne-ol"><li id="u2e87ea22" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">spa单页面就是url改变但是不进行页面刷新和跳转，之后控制数据显示的方式</span></li></ol><pre data-language="javascript" id="hXGXm" class="ne-codeblock language-javascript"><code>https://www.baidu.com
		hash模式
window.location.hash  = '#/test.html' 
  == &gt;  https://www.baidu.com/#/test

浏览器的前进后退不会导致页面刷新和跳转

通过监听hashchange事件来解决跳转之后的数据显示</code></pre><pre data-language="javascript" id="MRqLC" class="ne-codeblock language-javascript"><code>// https://www.baidu.com
// 第一个参数是保存当前页面用到的一些信息，第二个是title没用，第三个就是url
window.history.pushState({name:&quot;test&quot;}, &quot;page B&quot;, &quot;pageB.html&quot;);
//https://www.baidu.com/pageB.html

// history.state获取当前所在页面的state对象{name:&quot;test&quot;}</code></pre><ol start="2" class="ne-ol"><li id="ue8a298ca" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">spa页面的优缺点</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uc363eac5" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">与多页面应用对比的优点是：切换页面不需要多次请求html文件，不会刷新页面而且是局部重新加载。但是首屏加载慢，需要将所有的css，js进行加载。因为是js控制页面内容的显示，所以对html进行爬虫的时候爬不到页面内容不容易做seo优化。不过也有针对vue的多页面生成方案，将每个路由页面生成独立的html页面，但就变成了之前的形式</span></li><li id="ue9602a69" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">vue的nuxt和react的next是常见的服务端渲染方案（也称为同构渲染），</span><span class="ne-text" style="color: rgba(0, 0, 0, 0.75); font-size: 16px">服务端渲染首屏内容 + 生成客户端 SPA 相关资源。所以对于网速慢情况下的方案有优势，而且由于异步返回数据时爬虫爬不到所以服务端渲染是seo必须的。例如nuxt实现了</span><span class="ne-text" style="color: rgb(15, 23, 42); background-color: rgb(252, 252, 252); font-size: 16px">首次访问时使用服务端渲染，后续页面则采用客户端渲染。</span><img src="https://cdn.nlark.com/yuque/0/2023/png/28792475/1690879085604-9df0b649-4d47-45c2-8b61-a6f55e26f523.png" width="994" id="Sdent" class="ne-image"></li><li id="u908d86a9" data-lake-index-type="0"><span class="ne-text">SSG</span></li><li id="u48f4d2f1" data-lake-index-type="0"><span class="ne-text">qwik</span></li></ol></ol></details>
<details class="lake-collapse"><summary id="ue0db6199"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">composition api和mixin的区别</span></summary><p id="uee275709" class="ne-p"><span class="ne-text">都是将组件的公共逻辑或者配置提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件内部</span></p><p id="uc9bace2f" class="ne-p"><span class="ne-text">即可。这样既可以减少代码冗余度，也可以让后期维护起来更加容易。</span></p><ol class="ne-ol"><li id="uae4a9754" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">mixin最大的弊端就是使用抽离的逻辑的时候如果里面写错了代码没法溯源，控制台不报错。尤其是多人开发的时候，接手别人写的mixin会无从下手。</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ucf3b0ed4" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">mixin中的data数据在组件中也可以使用。</span></li><li id="u3320787b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">mixin中的方法在组件内部可以直接调用。</span></li><li id="u005771af" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">生命周期函数合并后执行顺序：先执行mixin中的，后执行组件的。</span></li><li id="u4abb6ec3" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">多个组件混入同个mixin，不会相互影响是独立的</span></li><li id="u5e6eff37" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">可以通过全局混入vue.mixin()来全局混入</span></li><li id="u3b6365e3" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">如果组件中的数据和mixin中的变量名和函数名冲突，组件中的数据会覆盖mixin中的数据</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u7bb5a581" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">mixin容易命名冲突</span></li><li id="ufb0f6b79" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">依赖不透明换句话说，依赖不是局部声明式的。</span></li></ol><p id="ud5aec4bf" class="ne-p" style="text-indent: 2em; margin-left: 2em"><span class="ne-text" style="font-size: 16px">mixin和使用它的组件之间没有层次关系。这意味着组件可以使用mixin中定义的数据属性（例如myData),但是mixin也可以使用假定在组件中定义的数据属性（例如myData)。以后的某天如果想修改mixin,包袱有点重。</span></p><ol start="4" class="ne-ol"><li id="ub4d0f273" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">hooks方式写的代码会正常报错</span></li></ol></details>
#### 四、代码实现
+ <font style="color:rgb(62, 62, 62);">实现一个节流函数? 如果想要最后一次必须执行的话怎么实现?</font>
+ <font style="color:rgb(62, 62, 62);">实现一个批量请求函数, 能够限制并发量?</font>
+ <font style="color:rgb(62, 62, 62);"> 数组转树结构，如果要在树中新增节点或者删除节点, 函数应该怎么扩展</font>
+ <font style="color:rgb(62, 62, 62);">截图怎么实现</font>

#### 五、node
+ <font style="color:rgb(62, 62, 62);">Nodejs 异步IO模型</font>
+ <font style="color:rgb(62, 62, 62);">Node的日志和负载均衡怎么做的</font>
+ <font style="color:rgb(62, 62, 62);">Node是怎么部署的? pm2守护进程的原理?</font>
+ <font style="color:rgb(62, 62, 62);">Node开启子进程的方法有哪些? 进程间如何通信? </font>
+ <font style="color:rgb(62, 62, 62);">那前后端的分工是怎样的？哪些后端做哪些node做</font>

#### 六、高级
+ <font style="color:rgb(62, 62, 62);">libuv</font>
+ <font style="color:rgb(62, 62, 62);">设计模式</font>
+ <font style="color:rgb(62, 62, 62);">webscoket的连接原理</font>
+ <font style="color:rgb(62, 62, 62);">虚拟列表怎么实现?</font>
+ <font style="color:rgb(62, 62, 62);">对前端工程化的理解</font>
+ <font style="color:rgb(62, 62, 62);">前端性能优化都做了哪些工作</font>
+ <font style="color:rgb(62, 62, 62);">Electron架构</font>
+ <font style="color:rgb(62, 62, 62);">微前端</font>
+ <font style="color:rgb(62, 62, 62);">Webworker</font>
+ <font style="color:rgb(62, 62, 62);">前端History路由配置 nginx</font>
+ <font style="color:rgb(62, 62, 62);">前端路由 a -> b -> c这样前进, 也可以返回 c -> b -> a, 用什么数据结构来存比较高效</font>
+ <font style="color:rgb(62, 62, 62);">小程序的架构? 双线程分别做的什么事情?</font>
+ <font style="color:rgb(62, 62, 62);">为什么小程序里拿不到dom相关的api</font>

<details class="lake-collapse"><summary id="ue649b049"><span class="ne-text" style="font-size: 16px">前端开发规范</span></summary><div id="ClgQW" class="ne-bookmark"><a href="https://juejin.cn/post/7257441221761040444?searchId=20230808160741984EDAA8E2B88EA41C27#heading-2" target="_blank">https://juejin.cn/post/7257441221761040444?searchId=20230808160741984EDAA8E2B88EA41C27#heading-2</a></div><div id="sJNHD" class="ne-bookmark"><a href="https://cz-git.qbb.sh/zh/cli/why" target="_blank">https://cz-git.qbb.sh/zh/cli/why</a></div></details>
<details class="lake-collapse"><summary id="ued987268"><span class="ne-text" style="color: rgb(62, 62, 62); font-size: 16px">前端图片相关的优化</span></summary><ol class="ne-ol"><li id="u4fd2d57b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">图片格式解析</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u19544d67" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">根据压缩划分</span></li></ol></ol><ol class="ne-list-wrap"><ol class="ne-list-wrap"><ol ne-level="2" class="ne-ol"><li id="uc023d5ac" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px"></span></li><li id="ubc162f0a" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">有损压缩(根据算法将人眼看不到的细节进行删除)：例如jpg</span></li><li id="u918245c2" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">无损压缩(根据算法将图片编码进行压缩，对图片质量无影响)：例如png，gif</span></li></ol></ol></ol><ol class="ne-list-wrap"><ol start="2" ne-level="1" class="ne-ol"><li id="u0be130ab" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px"></span></li></ol></ol><ol start="2" class="ne-ol"><li id="u015992e3" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">渐进式图片</span></li></ol></details>
#### 七、webpack与前端安全
+ <font style="color:rgb(62, 62, 62);">webpack打包流程</font>
+ <font style="color:rgb(62, 62, 62);">Webpack的原理, plugin loader 热更新等等  webpack5 模块联邦</font>
+ <font style="color:rgb(37, 41, 51);">Babel的原理</font>
+ <font style="color:rgb(37, 41, 51);">AST抽象语法树</font>
+ <font style="color:rgb(62, 62, 62);">错误捕捉</font>
+ <font style="color:rgb(62, 62, 62);">前端稳定性监控</font>
+ <font style="color:rgb(62, 62, 62);">前端内存处理</font>
+ <font style="color:rgb(62, 62, 62);">前端安全都了解哪些? xss csrf</font>
    - <font style="color:rgb(62, 62, 62);">csp是为了解决什么问题的?</font>
    - <font style="color:rgb(62, 62, 62);">https是如何安全通信的?</font>
    - <font style="color:rgb(62, 62, 62);">Https中间人攻击</font>

#### 八、小细节备忘录
##### 基础题
+ js中什么类型会转化为false ： 0，''，null，undefined，false，NaN
+ 判断变量正确类型：Object.prototype.toString.call()
+ NaN是number类型，不自等，但是在set数据类型中是判断相等的

<details class="lake-collapse"><summary id="u859c31fd"><span class="ne-text" style="font-size: 16px">var的变量提升是不赋值的，function的变量提升是赋值的</span></summary><pre data-language="javascript" id="WncVQ" class="ne-codeblock language-javascript"><code>var getName = function() {
    console.log(4);
}

function getName() {
    console.log(5);
}
getName()  // 4</code></pre></details>
+ 手写call和apply

<details class="lake-collapse"><summary id="udceee2b9"><span class="ne-text" style="font-size: 16px">连等操作：连等赋值与顺序无关，先全部解析出来再将右侧的值进行分别赋值</span></summary><pre data-language="javascript" id="tXMQL" class="ne-codeblock language-javascript"><code>let a = { n: 1 };
let b = a;
a.x = a = { n: 2 }; // 首先解析出a.x的地址，a的地址，然后将右边地址分别赋值给两侧
// a =&gt;{ n:2 }
// b =&gt;{ n:1,x:{ n:2 } }</code></pre></details>
<details class="lake-collapse"><summary id="ub74a1836"><span class="ne-text" style="font-size: 16px">async和await中await会先执行右侧代码，然后将await赋值操作及当前函数下面的代码放到微任务队列中</span></summary><pre data-language="javascript" id="pRtkW" class="ne-codeblock language-javascript"><code>let p;
async function f3() {
    p = await 18;    //从右到左执行，将赋值及以下植入微任务队列
                     //返回promise的resolve（）
    console.log(p);
}

f3();
console.log(1);
console.log(p);  
//1  undefined  18</code></pre><pre data-language="javascript" id="vLQpm" class="ne-codeblock language-javascript"><code>async function async1() {
    console.log(&quot;async1 start&quot;);
    await async2()
    console.log(&quot;async1 end&quot;);
}

async function async2() {
    console.log(&quot;async2&quot;);
}

console.log(&quot;script start&quot;);

setTimeout(function() {
    console.log('setTimeout')
}, 0)
async1()

new Promise(function(resolve) {
    console.log(&quot;promise1&quot;);
    resolve()
}).then(function() {
    console.log(&quot;promise2&quot;);
})

console.log(&quot;script end&quot;);
// scriptstart  async1start async2 promise1 scriptend async1end promise2 setTimeout</code></pre></details>
<details class="lake-collapse"><summary id="ua4764dd3"><span class="ne-text" style="font-size: 16px">什么是restful规范</span></summary><ol class="ne-ol"><li id="u7a9d473c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">前后端分离之后对api的一种规范或者风格，目的是使接口</span><strong><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">简化开发、结构清晰、符合标准、易于理解、易于扩展</span></strong></li><li id="ue57cfc5a" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">主要特点</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua13e073d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">URL 明确标识资源，使用http的不同方法来操纵资源</span><img src="https://cdn.nlark.com/yuque/0/2023/webp/28792475/1690870600659-c6237f25-22c1-473f-909a-ba05de83b67d.webp" width="970" id="ub9c165cf" class="ne-image"></li><li id="ubd3bd97f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">http状态码规范</span></li><li id="uc4617b18" data-lake-index-type="0"><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px">返回数据格式有 </span><span class="ne-text" style="color: rgb(255, 80, 44); background-color: rgb(255, 245, 245)">JSON</span><span class="ne-text" style="color: rgb(37, 41, 51); font-size: 16px"> 和 </span><span class="ne-text" style="color: rgb(255, 80, 44); background-color: rgb(255, 245, 245)">XML</span></li></ol></ol></details>
<details class="lake-collapse"><summary id="u19ca6e07"><span class="ne-text" style="font-size: 16px">项目中所遇到的难点</span></summary><ol class="ne-ol"><li id="ub1315501" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">避免耦合度过高</span></li></ol></details>
<details class="lake-collapse"><summary id="u91b8334d"><span class="ne-text" style="font-size: 16px">主动询问的部分</span></summary><ol class="ne-ol"><li id="u26a0e28b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">该岗位是新项目还是老员工辞职出来的</span></li><li id="u9ddc999d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px"></span></li></ol></details>

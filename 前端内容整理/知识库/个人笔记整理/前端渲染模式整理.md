[万字长文助你搞懂现代网页开发中常见的10种渲染模式-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2351500)

[现代前端框架的渲染模式 - 掘金](https://juejin.cn/post/7241027834490437669#heading-9)

[https://www.youtube.com/watch?v=kUs-fH1k-aM](https://www.youtube.com/watch?v=kUs-fH1k-aM)

什么是渲染模式：就是浏览器展示出页面来，请求的html文件内容是服务端生成的还是客户端生成的，还是混合的

首先要知道的是mpa和spa是两种前端架构，区别是新页面到底是<font style="color:#DF2A3F;">新的html文件</font>还是<font style="color:#DF2A3F;">原来的html文件通过js去修改</font>的。传统的ssr渲染模式就是通过mpa架构来实现的

CSR、SSR 和 SSG 都不属于新兴的渲染技术。虽然 SSR 和 SSG 在前几年迎来了一波性能优化趋势，但实际发展的只是增量静态再生成（ISR）和流式 SSR 

### CSR：client side rendering
类似vue和react这种spa页面，返回的html是个空页面，通过返回的js文件去渲染页面和交互返回的数据修改页面

![](https://cdn.nlark.com/yuque/0/2024/png/28792475/1710897660369-bb63efa1-04e4-4cf3-972e-c79bd20ed7fe.png)

### SSR：server side rendering
SSR 把数据拉取放到了服务端，因为离数据源比较近，数据拉取的速度会快一点。但这也不是完全没有副作用，因为需要在服务端等待数据就绪, TTFB(Time to First Byte) 相比 CSR 会长一点。

将服务端生成的html返回，然后去请求css和js文件，此时渲染页面渲染好了，js还在加载，所以有一个交互失灵的时间段，js加载完成后完成整个页面渲染，这个html文件加载完但是js加载的时间段称之为（<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">Hydration 水合/注水</font><font style="color:rgb(37, 41, 51);">)</font>

<font style="color:#DF2A3F;">FCP</font>(First Contentful Paint) 相比 CSR 提前了, 但是 <font style="color:#DF2A3F;">TTI</font>(Time to Interactive) 并没有太多差别。只是用户可以更快地看到内容了。

![](https://cdn.nlark.com/yuque/0/2024/png/28792475/1710897753970-64234c33-8f7e-46f3-89c2-3abbeb3252fe.png)

![](https://cdn.nlark.com/yuque/0/2024/png/28792475/1710921467479-487255db-917a-4ad1-8225-cd7af263cadc.png)

![](https://cdn.nlark.com/yuque/0/2024/png/28792475/1710926585071-0e386d97-ab0d-4ff2-b74e-1dcfc5f5c287.png)

```jsx
// 第一页：显示所有可用的虚拟币

import Link from "next/link";
export default function Index() {
 return (
   <div>
     <h1>Cryptocurrency Price App</h1>
     <ol>
       <li>
         <Link href="./price/btc">Bitcoin </Link>
       </li>
       <li>
         <Link href="./price/eth">Ethereum </Link>
       </li>
       <li>
         <Link href="./price/xrp">Ripple </Link>
       </li>
       <li>
         <Link href="./price/ada">Cardano </Link>
       </li>
     </ol>
   </div>
 );
}
```

```jsx
// 第二页，从Coingecko API获取的不同交易所的BTC价格
import ClientPage from "../../components/Client";

async function getCurrentPrice(market) {
   const res = await fetch( `https://api.coingecko.com/api/v3/exchanges/${market}/tickers?coin_ids=ripple%2Cbitcoin%2Cethereum%2Ccardano`
   );
   console.log("fetched");
   const data = await res.json();
   const prices = [];
   for (const info of data.tickers) {
     if (info.target === "USDT") {
       const name = info.base;
       const price = info.last;
       prices.push({ [name]: price });
     }
   }
   return prices;
}

export default async function Price() {
  // 先获取所有的价格
 async function fetchMarketPrices() {
   try {
     const prices = await Promise.all([
       getCurrentPrice("binance"),
       getCurrentPrice("kucoin"),
       getCurrentPrice("bitfinex"),
       getCurrentPrice("crypto_com"),
     ]);
     const allPrices = {
       binance: prices[0],
       kucoin: prices[1],
       bitfinex: prices[2],
       crypto_com: prices[3],
     };

     return allPrices;
     // Log the fetched prices to the console
   } catch (error) {
     console.log(error);
   }
 }

 const allPrices = await fetchMarketPrices();

 return (
   <div>
     {allPrices && Object.keys(allPrices).length > 0 ? (
       <ClientPage allPrices={allPrices} />
     ) : (
       <p>No data available.</p>
     )}
   </div>
 );
}
```

```jsx
"use client";
// 因为需要用到后端返回的数据
import { useEffect, useRef } from "react";
import Btn from "@/app/components/Btn"; // 切换明暗主题的按钮
import { usePathname } from "next/navigation";

export default function ClientPage({ allPrices }) {
 const pathname = usePathname();
 let ID = pathname.slice(-3).toUpperCase();

 const containerRef = useRef(null);

 function fetchMode() {
   const preferredMode = localStorage.getItem("mode");
   if (preferredMode === "dark") {
     containerRef.current.classList.add("dark-mode");
   } else if (preferredMode === "light") {
     containerRef.current.classList.add("light-mode");
   }
 }

 useEffect(() => {
   fetchMode();
 }, []);

 return (
   <div className="container" ref={containerRef}>
     <h2>{ID}</h2>
     {Object.keys(allPrices).length > 0 ? (
       <ul>
         {Object.keys(allPrices).map((exchange) => (
           <li key={exchange}>
             {exchange}: {allPrices[exchange][0][ID]}
           </li>
         ))}
       </ul>
     ) : (
       <p>No data available.</p>
     )}
     <Btn container={containerRef} />
   </div>
 );
}
```

```jsx
export default function Btn({ container }) {
 function toggleMode() {
   container.current.classList.toggle("dark-mode");
   container.current.classList.toggle("light-mode");

   // Save the user's preference in localStorage (optional)
   const currentMode = container.current.classList.contains("dark-mode") ? "dark" : "light";
   localStorage.setItem("mode", currentMode);
 }

 // Check the user's preferred mode on page load (optional)

 return (
   <div>
     <button className="toggle-btn" onClick={() => {toggleMode()}}>
       Toggle Mode
     </button>
   </div>
 );
}
```

### SSG：static side generation
构建的时候也就是npm run build的时候生成静态的html文件，访问的时候直接返回就行了，所以适合那种内容固定的网站，比如博客、公司首页。不适用于 shows frequently updated data, and the page content changes on every request.

优点

+ 相比 SSR, 因为不需要服务端运行时、数据拉取，TTFB/FCP 等都会提前。

缺点

+ 和 SSR 一样，也有客户端渲染程序、需要进行 Hydrate。 对于内容为中心的站点来说，实际上并不需要太多交互，客户端程序还有较大压缩的空间。<font style="color:#DF2A3F;">Qwik</font>很厉害，只有当你需要交互的时候才去下载需要的js文件，所以完全省略了hydration的时间
+ 在构建时渲染，如果内容变更，需要重新构建，比较麻烦

![](https://cdn.nlark.com/yuque/0/2024/png/28792475/1710926668882-b012132e-c755-485e-b84c-2a12914fb731.png)

![](https://cdn.nlark.com/yuque/0/2024/png/28792475/1710926688139-1d656e74-0fff-4997-83fb-fb38119c114b.png)

### ISR：incremental static geneartion
我不想每次文件修改了都得重新构建一下，我想启动一个node服务去监听文件，设定一段时间后自动修改



### 一些优化的点
#### 优化水合时间
如何缩短水合时间呢，能不能减少一上来就下载的js文件的大小，不影响首页的渲染交互，用异步再去请求其他的js文件呢，这就是利用代码分割生成的<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">渐进式水合 （Progressive Hydration ）</font>

<font style="color:rgb(37, 41, 51);">React 18 官方支持了渐进式水合（官方叫 </font><font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">Selective Hydration</font><font style="color:rgb(37, 41, 51);">）</font>

#### <font style="color:rgb(37, 41, 51);">优化html生成时间</font><font style="color:rgb(37, 41, 51);background-color:#FBE4E7;"></font>
1. 等你server端生成html完之后再返回，那能不能就跟gpt一样边生成边返回呢，浏览器是支持流式html加载的，所以我们通过[renderToNodeStream](https://link.juejin.cn/?target=https%3A%2F%2Freact.dev%2Freference%2Freact-dom%2Fserver%2FrenderToNodeStream)<font style="color:rgb(37, 41, 51);"> </font><font style="color:rgb(37, 41, 51);">→ 流式响应返回，就会优化白屏时间。这叫</font><font style="color:#DF2A3F;background-color:#FBE4E7;">SSR with streaming</font><font style="color:rgb(37, 41, 51);"> - 流式 SSR</font>

![](https://cdn.nlark.com/yuque/0/2024/png/28792475/1710899337966-5a8923eb-f612-4027-8c2e-20f797b65913.png)

2. 有些慢组件，先别渲染，后面再通过流式传过来在加载，这时候会提高TTFP的时间，这叫<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">选择性水合（Progressive Hydration）</font>

> <font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">慢组件</font><font style="color:rgb(102, 102, 102);background-color:rgb(248, 248, 248);">通常指的是：需要异步获取数据、体积较大、或者是计算量比较复杂的组件。</font>
>

<details class="lake-collapse"><summary id="u07163147"><span class="ne-text" style="font-size: 14px">拿nextjs作为案例</span></summary><p id="ub07b837b" class="ne-p"><span class="ne-text" style="color: rgb(37, 41, 51)">开启 Selective Hydration 很简单，我们只需要用 </span><span class="ne-text" style="color: rgb(37, 41, 51); background-color: #FBE4E7">Suspend</span><span class="ne-text" style="color: rgb(37, 41, 51)"> 包裹起来，提示 React 这可能是一个‘慢组件’，可以跳过他：</span></p><pre data-language="tsx" id="FsbXy" class="ne-codeblock language-tsx"><code>export default async function WithoutSelective() {
  // 获取关键数据
  const crucialData = await getCrucialData()

  return (
    &lt;div&gt;
      &lt;h1&gt;Without Selective&lt;/h1&gt;
      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;
      &lt;p&gt;crucial data: {crucialData.data}&lt;/p&gt;
      &lt;Suspense fallback=&quot;foo loading&quot;&gt;
        &lt;Foo&gt;&lt;/Foo&gt;
      &lt;/Suspense&gt;
      &lt;Suspense fallback=&quot;bar loading&quot;&gt;
        &lt;Bar&gt;&lt;/Bar&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  )
}
</code></pre><p id="ud8d78473" class="ne-p"><span class="ne-text">现在来看运行结果：</span></p><p id="u34e4693f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/webp/28792475/1710902951169-4985a49e-4f26-4d0c-bc73-59dfa3da01e1.webp" width="1340" id="u2ddc643e" class="ne-image"></p><p id="ua41b7b9b" class="ne-p"><span class="ne-text"> TTFB 提前了！但是完整的请求时间没变。</span></p><p id="u2d175cc0" class="ne-p"><span class="ne-text"> </span></p><p id="u10709e4d" class="ne-p"><span class="ne-text">当 Foo 和 Bar 就绪后，Next.js 会将渲染结果写入流中。怎么做到的？</span></p><p id="uc2c78ce6" class="ne-p"><span class="ne-text"> </span></p><p id="u635a5561" class="ne-p"><span class="ne-text">看一眼 HTML 就知道了：</span></p><p id="u2095b60a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/webp/28792475/1710902951197-a630d8e7-5db8-4a3d-825c-eb8c196f895f.webp" width="1338" id="u07d21048" class="ne-image"></p><p id="u28f0d56f" class="ne-p"><span class="ne-text">对于</span><span class="ne-text">慢组件</span><span class="ne-text">，React 会先渲染 Suspend 的 fallback 内容，并留一个插槽。</span></p><p id="u0ace3290" class="ne-p"><span class="ne-text">继续往下看，可以看到 Foo、Bar 的渲染结果：</span></p><p id="uf939f0e5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/webp/28792475/1710902951217-56c0efb9-7e99-4bc7-89fa-7b917e0feed6.webp" width="1278" id="u8f9b6cb0" class="ne-image"></p><p id="u6c68938f" class="ne-p"><span class="ne-text">接着将渲染结果替换掉插槽。用于后续的水合。</span></p><p id="ub4084ddf" class="ne-p"><span class="ne-text"> </span></p><p id="uaa0076e6" class="ne-p"><span class="ne-text">总之，在服务端，Selective Hydration 在 SSR With Streaming 的基础上，通过选择性地跳过一些低优先级的慢组件来优化了 TTFB(主要的，相对于 FCP 等指标也优化了)，更快地向用户呈现页面。</span></p><p id="u5061b962" class="ne-p"><br></p><pre data-language="tsx" id="A7b21" class="ne-codeblock language-tsx"><code>
function delay(time: number) {
  return new Promise((resolve) =&gt; setTimeout(resolve, time))
}

/**
 * 获取关键数据
 */
function getCrucialData() {
  return delay(1000).then(() =&gt; {
    return {
      data: Math.random(),
    }
  })
}

function getData(time: number) {
  return delay(time).then(() =&gt; {
    return {
      data: Math.random(),
    }
  })
}

const Foo = async () =&gt; {
  const data = await getData(1000)

  return &lt;div&gt;foo: {data.data}&lt;/div&gt;
}

const Bar = async () =&gt; {
  const data = await getData(2000)

  return &lt;div&gt;bar: {data.data}&lt;/div&gt;
}

/**
 * 页面 🔴
 *
 */
export default async function WithoutSelective() {
  // 获取关键数据
  const crucialData = await getCrucialData()

  return (
    &lt;div&gt;
      &lt;h1&gt;Without Selective&lt;/h1&gt;
      &lt;p&gt;This page is rendered without Selective Hydration.&lt;/p&gt;
      &lt;p&gt;crucial data: {crucialData.data}&lt;/p&gt;
      &lt;Foo&gt;&lt;/Foo&gt;
      &lt;Bar&gt;&lt;/Bar&gt;
    &lt;/div&gt;
  )
}</code></pre><p id="u4a89dbc1" class="ne-p"><span class="ne-text" style="color: rgb(37, 41, 51)">运行结果：浏览器等待响应的时间为 3s </span><img src="https://cdn.nlark.com/yuque/0/2024/webp/28792475/1710902808963-d31de77a-7f53-454c-8379-a2d7725becb5.webp" width="1512" id="u83ef9604" class="ne-image"><span class="ne-text" style="color: rgb(37, 41, 51)"> 即所有服务端组件（Server Component） 就绪后才会有实际的内容输出。</span></p></details>
<font style="color:rgb(37, 41, 51);">   
  
</font>



### SEO优化
难以避免肯定要说到SEO优化，一会总结

[优化SPA：使得网站对SEO更友好-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2081692)

[https://v2ex.com/t/887854](https://v2ex.com/t/887854)

[2023 年前端十大 Web 发展趋势](https://www.163.com/dy/article/HTFAHKDL0511D3QS.html)



